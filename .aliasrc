# common shell alias / functions
# author: delucks
# use freely, share and contribute

# common exports, sourcing functions
alias cmd_exists="eval \"which $1\" >/dev/null 2>&1"
export LS_COLORS=
export LC_ALL="en_US.UTF-8"
if test -d "$HOME/dev/go/"
then
  export GOBIN="$HOME/dev/go/bin"
  export GOPATH="$HOME/dev/go"
fi
if cmd_exists vim
then
  export EDITOR='vim'
else
  export EDITOR='vi'
fi
if cmd_exists less
then
  export PAGER='less'
fi

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

# vc
if cmd_exists svn
then
  alias sup='svn update'
  alias sch='svn checkout $@'
  alias ss='svn status'
  alias sadd='svn add $@'
  alias scm='svn commit'
fi
if cmd_exists git
then
  alias getget='git pull'
  alias gita='git add'
  alias gitd='git diff'
  alias gitm='git mv'
  alias gitr='git rm'
  alias gitp='git push'
  alias gitc='git commit'
  alias gits='git status'
fi

# platform detection
if [[ "$OSTYPE" == "linux-gnu"* ]]
then
  # linux specific aliases
  export GNUSTEP_USER_ROOT="${HOME}/GNUstep"
  export TERM=xterm-256color
  alias lscan="sudo nmap -sP $(ip addr show | grep 'inet ' | grep global | awk '{print $2}') | grep -v -e Host\ is\ up -e done -e Starting"
  alias prdev="ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' '"
  alias paddr="ip addr show primary dev $(ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' ') | grep inet\ | awk '{print $2}'"
  alias ls='ls --color=auto'
  alias la='ls -aChkopl --group-directories-first --color=auto'
  alias lsg='ls -aChkopl --group-directories-first --color=auto | grep "$@"'
  if test -f /etc/debian_version
  then
    # debian specific
    alias packages="dpkg -l | awk '{$1=$3=$4=\",\"}1' | column -t -s,"
  elif cmd_exists pacman
  then
    # archlinux specific
    alias y='yaourt'
    alias orphan='pacman -Qtdq'
    sizes() {
    	awk 'BEGIN{while (("pacman -Qi" |getline) > 0){ if ($0 ~ /Name/) {name=$3};{if ($0 ~ /Size/) {size=$4/1024;print name": ",size,"Mb"|"sort -k2 -n|column -t"}}}}'
    }
    alias owner='pacman -Qo $(which $1)'
    alias archey='archey --config=~/.config/archey3.cfg'
  fi
  cfat() {
  	sudo mount -t vfat /dev/sdb1 /mnt/vfat
  	log ok "Mounted."
  	sudo cp $@ /mnt/vfat/
  	log ok "Copied."
  	read -p "Press Enter to Unmount:"
  	sudo umount /mnt/vfat
  	log ok "Unmounted."
  }
  alias mfat='sudo mount -t vfat /dev/sdb1 /mnt/vfat'
elif [[ "$OSTYPE" == "darwin"* ]]
then
  # osx
  alias ls='ls -G'
  alias la='ls -aChGkopl --group-directories-first'
  alias lsg='ls -aChGkopl --group-directories-first | grep "$@"'
else
  alias la='ls -aChkopl --group-directories-first'
  alias lsg='ls -aChkopl --group-directories-first | grep "$@"'
fi

# beets
if cmd_exists beet
then
  alias bim='beet im'
  alias bls='beet ls'
  alias brm='beet remove'
  alias bvr='beet version'
fi

# procs
psgrep() {
	if [ $# -gt 0 ]; then
		ps -fp $(pgrep -f $1)
	else
		log err "Needs at least one argument"
    return 1
	fi
}

# herbsluftwm helpers
if cmd_exists herbstclient
then
  alias hkeys="cat ~/.config/herbstluftwm/autostart| egrep '^([\t\ ])?hc keybind' | awk '{print \$3}'"
  alias hmods="hkeys | grep mod | sed 's/\$mod\-//g' | sort"
  alias currtag="herbstclient tag_status | sed -e 's/[:|\.][a-zA-Z]//g' -e 's/[\t\ #]//g'"
  alias hc='herbstclient'
fi

# docker
if cmd_exists docker
then
  docker-remove() {
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi 2>&1 | awk '{print $12}' | uniq | xargs sudo docker rm
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi
  }
  alias daddr="sudo docker ps | tail -1 | awk '{print $1}' | xargs sudo docker inspect -f '{{.NetworkSettings}}' "
fi

# networking
alias router="routel | egrep '^\ +default' | grep -v lo | awk '{print $2}'"
alias s='ssh'
alias ssh-hosts="grep 'Host\ ' $HOME/.ssh/config | awk '{print \$NF}'"

# misc
alias ts='while read line; do date +"%F %T $line"; done'
alias ks='killall spotify'
alias cdiff='dwdiff --no-common -c'
alias big="echo $1 | figlet"
alias vc='vim -c ":RangerChooser"'
alias \:q='exit'
alias strings='strings -a'
alias whereami='uname -n'
alias d='date +%R'
alias violet='wmname LG3D && violet'
alias wgot='wget -e robots=off -r -nc -np '
alias rot13='tr "a-zA-Z" "n-za-mN-ZA-M"'
alias iploc='curl ipinfo.io/$(dig $1 +short)'
alias mkdir='mkdir -p'
alias datehelp='for F in {a..z} {A..Z} :z ::z :::z;do echo $F: $(date +%$F);done|sed "/:[\ \t\n]*$/d;/%[a-zA-Z]/d"'
alias serve='python2 -m SimpleHTTPServer'
alias apropy="pydoc2 -k $1 2>/dev/null"
alias apropos="man -k" # yeah, some platforms don't do this
alias count='sort | uniq -c | sort -nr'
if cmd_exists chromium
then
  alias cal="chromium 'https://www.google.com/calendar/render'"
fi
if cmd_exists mencoder
then
  alias flvjoin='mencoder -forceidx -of lavf -oac pcm -ovc copy -o output.flv '
fi
if cmd_exists mplayer
then
  say() {
  	if [[ "${1}" =~ -[a-z]{2} ]]; then
  		local lang=${1#-};
  		local text="${*#$1}";
  	else 
  		local lang=${LANG%_*};
  		local text="$*";
  	fi;
  	mplayer "http://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&q=${text}" &> /dev/null ;
  }
  alias wvud='mplayer http://128.175.76.123:8000/WVUD-FM123.mp3'
  alias webcam='mplayer tv:// -tv driver=v4l2:width=640:height=480:device=/dev/video0 -fps 15 -vf screenshot'
fi

# functions 

initializeANSI()
{
  esc="\033"
  blackf="${esc}[0;30m"
  redf="${esc}[0;31m"
  greenf="${esc}[0;32m"
  yellowf="${esc}[0;33m"
  bluef="${esc}[0;34m"
  purplef="${esc}[0;35m"
  cyanf="${esc}[0;36m"
  whitef="${esc}[0;37m"
  blackb="${esc}[0;40m"
  redb="${esc}[0;41m"
  greenb="${esc}[0;42m"
  yellowb="${esc}[0;43m"
  blueb="${esc}[0;44m"
  purpleb="${esc}[0;45m"
  cyanb="${esc}[0;46m"
  whiteb="${esc}[0;47m"
  boldon="${esc}[0;1m"
  boldoff="${esc}[0;22m"
  italicson="${esc}[0;3m"
  italicsoff="${esc}[0;23m"
  ulon="${esc}[0;4m"
  uloff="${esc}[0;24m"
  invon="${esc}[0;7m"
  invoff="${esc}[0;27m"
  reset="${esc}[0m"
}
initializeANSI

log() {
  if [ $# -gt 1 ]
  then
    if [[ "$1" == "err"* ]]
    then
      shift
      echo -e "${redf}$@${reset}"
    elif [[ "$1" == "ok"* ]]
    then
      shift
      echo -e "${greenf}$@${reset}"
    elif [[ "$1" == "fatal"* ]]
    then
      shift
      echo -e "${redf}$@${reset}"
      return 1
    else
      shift
      echo -e "$@"
    fi
  else
    echo -e "$@"
  fi
}

# argcheck()
#   verify the number of arguments passed to another function
#
#   usage: 
#     argcheck {expected number} ${FUNCNAME[0]} {...more args...}
#   for a three-argument script:
#     argcheck 3 ${FUNCNAME[0]} $@
#   in typical usage: (pop return val out to calling function)
#     argcheck 3 ${FUNCNAME[0]} $@ || return 1
argcheck() {
  if [[ $# -lt 1 ]]
  then
    log err "argcheck() requires at least two arguments:"
    log err "1. the number of arguments to validate"
    log fatal '2. ${FUNCNAME[0]} of your function'
  else
    ARGC=$1 # the expected amount of arguments
    shift
    SCR=$1 # the func name
    shift
    IFS=' ' read -ra ARGS <<< "$@" # split the rest of the args on ' '
    if [[ "${#ARGS[*]}" -lt "$ARGC" ]]
    then
      # invalid amount of arguments!
      log fatal "$SCR requires at least $ARGC argument(s)"
      return 1 # with a ||, this gets returned by the caller
    else
      return 0
    fi
  fi
}

if test -f "$HOME/scripts/x86.py"
then
  x() {
    argcheck 1 ${FUNCNAME[0]} $@ || return 1
  	python2 "$HOME/scripts/x86.py" $1 | lynx -stdin -dump
  }
fi

hex() {
  argcheck 3 ${FUNCNAME[0]} $@ || return 1
	python2 -c "print hex($1 $2 $3)"
}

int() {
  argcheck 1 ${FUNCNAME[0]} $@ || return 1
	python2 -c "print int('$1',16)"
}

# wikipedia summary
if cmd_exists curl
then
  function wiki {
  	if [ $# -eq 1 ]; then
  		foo=4
  	else
  		foo=$2
  	fi
  	curl -s -L -d "search=$1" http://en.wikipedia.org/w/index.php | grep '<p>\|<h3>\|<h2>' | head -n$foo | w3m -T text/html -dump | sed 's/(Listen.*)//g'
  	#curl -s -L -d "search=Linux" http://en.wikipedia.org/w/index.php | grep '<p>' | head -n2 | w3m -T text/html -dump | sed 's/\^\[.*\]//g'
  }
fi

# intel-specific brightness
if test -f /sys/class/backlight/intel_backlight/brightness
then
  b() {
  	if [ $# -eq 0 ]; then
  		cat /sys/class/backlight/intel_backlight/brightness
    elif [[ "$1" -eq "max" ]]; then
      echo "$(cat /sys/class/backlight/intel_backlight/max_brightness)" | sudo tee -a /sys/class/backlight/intel_backlight/brightness
    else
  		echo "${1}" | sudo tee -a /sys/class/backlight/intel_backlight/brightness
  	fi
  }
fi

# cd and ls at once
cl() {
	if [ -d "$1" ]; then
		cd "$1"
		ls
	else
		log fatal "cl(): $1: Directory not found"
	fi
}

mkcd() {
  mkdir -p "$1"
  cd "$1"
}

man() {
	env \
		LESS_TERMCAP_mb=$(printf "\e[1;31m") \
		LESS_TERMCAP_md=$(printf "\e[1;31m") \
		LESS_TERMCAP_me=$(printf "\e[0m") \
		LESS_TERMCAP_se=$(printf "\e[0m") \
		LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
		LESS_TERMCAP_ue=$(printf "\e[0m") \
		LESS_TERMCAP_us=$(printf "\e[1;32m") \
			man "$@"
}

# common valgrind usages
if cmd_exists valgrind
then
  alias memcheck='valgrind --tool=memcheck $@ --leak-check=full'
  valhalla() {
  	if [ "$#" == "0" ]; then
  		make
  		valgrind --tool=memcheck ./*.exe --leak-check=full
  	else
  		g++ -g "$1" -o "$(basename $1).out" && valgrind --tool=memcheck ./"$(basename $1).out" "${@:2}" --leak-check=full
  	fi
  }
fi

# recursive grep...
rgrep() {
  argcheck 1 ${FUNCNAME[0]} $@ || return 1
  grep -riI $1 .
}

# ...and find...
rfind() {
  argcheck 1 ${FUNCNAME[0]} $@ || return 1
  find . -name "*$1*"
}

# ...with vim!
vfind() {
  argcheck 1 ${FUNCNAME[0]} $@ || return 1
  vim $(find . -type f -name "*$1*")
}

alias rf='rfind'
alias vf='vfind'

if test -d "$HOME/notes/"
then
  note() {
    argcheck 1 ${FUNCNAME[0]} $@ || return 1
  	FILE="$HOME/notes/$1.txt"
  	if [ -f $FILE ];
  	then
  		log ok "$FILE exists"
  		vim "$FILE"
  	else
  		touch "$FILE"
  		echo "$1" | figlet > "$FILE"
  		echo "Note from $(date)" >> "$FILE"
  		vim "$FILE"
  	fi
  }
fi

ccd() {
  argcheck 2 ${FUNCNAME[0]} $@ || return 1
	FILE="$1"
	if [ ! -f "$FILE" ];
	then
		log fatal "File not found"
		return 1
	fi
	DIR="$2"
	if [ ! -d "$DIR" ];
	then
		log fatal "Dir not found"
		return 1
	fi
	cp -r "$FILE" "$DIR"
	cd "$DIR"
	pwd
}

# add a directory to path, but only if it exists
addp() {
  #argcheck 1 ${FUNCNAME[0]} $@ || return 1
  if [[ -d "$1" ]]
  then
    case $1 in
      */)
        TRIMMED=$(echo $1 | sed 's/\/$//g')
        [[ "$PATH" == *"$TRIMMED"* ]] || export PATH="$TRIMMED:$PATH"
        ;;
      *)
        [[ "$PATH" == *"$1"* ]] || export PATH="$1:$PATH"
        #export PATH="$1:$PATH"
        ;;
    esac
    return 0
  fi
  #echo "Path unavailable"
  return 1
}

# source a file, but only if it exists
sourcep() {
  if [[ $# -lt 1 ]]
  then
    log fatal "Use: sourcep {path to source}"
    return 1
  fi
  if [[ -f "$1" ]]
  then
    source "$1"
    return 0
  fi
  #echo "Path unavailable"
  return 1
}

silent() {
  if [ $# -lt 1 ];
  then
    log fatal "silent() requires a command argument"
    return 1
  fi
  eval "$1 2>/dev/null 1>&2"
}

stdfile() {
  if [ $# -lt 1 ];
  then
    log fatal "stdfile() requires a command argument"
    return 1
  fi
  eval "$1 2>./stderr 1>./stdout"
}

lss() {
  H=$(echo $1 | awk -F':' '{print $1}')
  F=$(echo $1 | awk -F':' '{print $2}')
  /usr/bin/ssh $H "ls $F"
}

histogram() {
  if [[ $# -lt 1 ]]
  then     
    log fatal "Usage: histogram {column to histogram on} [{fieldsep}]"
    return 1
  elif [[ $# -lt 2 ]]
  then
    COL="\$$1"
    awk "{print $COL}" | sort | uniq -c | sort -nr
  else
    COL="\$$1"
    awk -F"$2" "{print $COL}" | sort | uniq -c | sort -nr
  fi
  return 0
}

# expand my environment pls
sourcep "$HOME/ansible/hacking/env-setup"
sourcep "$HOME/.localaliasrc"
addp "$HOME/dev/go/bin"
addp "$HOME/bin"
addp "$HOME/.gem/ruby/2.1.0/bin"
alias a="source $HOME/.aliasrc"
