#!/usr/bin/env bash
# common shell alias / functions
# author: delucks
# use freely, share and contribute
# vi:syntax=sh

alias cmd_exists="hash 2>/dev/null"
export LS_COLORS=
export LC_ALL="en_US.UTF-8"
if cmd_exists vim
then
  export EDITOR='vim'
else
  export EDITOR='vi'
fi
export PAGER='less -r'

# add a directory to PATH, but only if it exists and if it's not already in PATH
pathappend() {
  for pathname in "$@"; do
    if test -d "$pathname" && [[ ":$PATH:" != *":$pathname:"* ]]; then
      PATH="${PATH:+"$PATH:"}$pathname"
    fi
  done
}

pathprepend() {
  for ((i=$#; i>0; i--)); do
    pathname=${!i}
    if test -d "$pathname" && [[ ":$PATH:" != *":$pathname:"* ]]; then
      PATH="${PATH:+"$PATH:"}$pathname"
    fi
  done
}

# source a file, but only if it exists
sourcep() {
  if [[ $# -lt 1 ]]
  then
    echo "Usage: sourcep <path to source>"
    return 1
  fi
  if [[ -f "$1" ]]
  then
    # shellcheck disable=SC1090
    source "$1"
    return 0
  fi
  return 1
}

# This file includes fallbacks if delucks/multitool isn't installed in ~/bin
# Also, prepending here allows me to drop scripts into ~/bin and override system executables by name
pathprepend "$HOME/bin"

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

if cmd_exists git
then
  alias gita='git add'
  alias gitd='git diff'
  alias gits='git status'
  alias gitl='git log --all --graph --pretty=format:"%Cred%h%Creset %C(bold blue)%an%Creset :%C(yellow)%d%Creset %s %Cgreen(%cr) %Creset"'
fi

# platform detection
if [[ "$OSTYPE" == "linux-gnu"* ]]
then
  # linux specific aliases
  alias ls='ls --color=auto'
  alias la='ls -aChkopl --group-directories-first --color=auto'
  alias errno="grep '#define' /usr/include/asm-generic/errno.h"
  ununix() {
    date -d "@$1"
  }
  alias suspend='pm-suspend'  # I don't care about suspending my shell, what is this, 1980?
elif [[ "$OSTYPE" == "darwin"* ]]
then
  # osx
  alias ls='ls -G'
  alias la='ls -aChGkopl --group-directories-first'
  alias ununix='date -r'
  alias errno="grep '#define' /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h"
else
  alias la='ls -aChkopl --group-directories-first'
fi
alias l='exa -l --git -h'

# This adds an argument to BSD paste to accept stdin by default
# The only use case I have for paste is joining standard input
mypaste() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]
  then
    paste "$@"
  else
    paste "$@" -
  fi
}
alias paste=mypaste

alias lt='ls -lt'
alias sx='ssh-agent startx'
alias :q='exit'
alias strings='strings -a'
alias trace='mtr -rw4 -c 5'
alias whereami='echo "$(uname -n) in $(pwd)"'
alias d='date +%R'
alias wgot='wget -e robots=off -r -nc -np '
alias rot13='tr "a-zA-Z" "n-za-mN-ZA-M"'
alias mkdir='mkdir -p'
alias datehelp='for F in {a..z} {A..Z} :z ::z :::z;do echo $F: $(date +%$F);done|sed "/:[\ \t\n]*$/d;/%[a-zA-Z]/d"'
alias ve='source $(find $(git rev-parse --show-toplevel 2>/dev/null) -name activate | grep -v hooks | head -1) &> /dev/null'
alias apropy="pydoc -k"
alias apropos="man -k" # yeah, some platforms don't do this
alias meh='echo "¯\_(ツ)_/¯"'
alias whom='who'
alias tmuxa='tmux a'
alias sl='ls'
if cmd_exists ncdu; then
  alias ncdu='ncdu --color dark'
fi

# tx and ta are my two tmux manipulation functions
#
# tx() creates a tmux session at a path, the current directory by default
# ta() attaches a tmux session (using fzf if available)

tx() {
  # Opens a tmux session named after the basename of a path
  DIR="${1:-.}"
  # shellcheck disable=2086
  RESOLVED="$(cd $DIR 2>/dev/null && pwd -P)"  # Cross-platform, readlink is Linux specific
  # shellcheck disable=2086
  SESSION_NAME="$(basename $RESOLVED)"
  # shellcheck disable=2086
  tmux new-session -A -c "$RESOLVED" -s "${SESSION_NAME//./_}"
}

ta() {
  if cmd_exists fzf; then
    fzf-tmux-attach
    return $?
  fi
  tmux a
}

if ! cmd_exists log
then
  log() {
    echo "$@"
  }
fi

if cmd_exists figlet
then
  alias big="figlet -t"
  figletsample() {
    for font in $(find /usr -name '*.flf' -type f | sort -u); do echo "$font"; echo "${1:-sample}" | figlet -f "$font"; echo; echo; echo; done
  }
fi

ssidgrep() {
  if [[ $# -lt 1 ]]; then
    log "Usage: ssidgrep <Regex matching SSID from network management program" err
    return 1
  fi
  if cmd_exists netctl
  then
    netctl list | grep -E "$1" | awk '{print $NF}' | xargs -L 1 sudo netctl start
  elif cmd_exists nmcli
  then
    nmcli c show | grep -E "$1" | awk '{print $2}' | xargs -L 1 sudo nmcli c up
  else
    log "ssidgrep requires either NetworkManager or systemd-netctl to be installed" err
    return 1
  fi
}

if cmd_exists mplayer
then
  say() {
    if [[ "${1}" =~ -[a-z]{2} ]]; then
      local lang=${1#-};
      local text="${*#$1}";
    else
      local lang=${LANG%_*};
      local text="$*";
    fi;
    mplayer "http://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&q=${text}" &> /dev/null ;
  }
  alias wvud='mplayer http://128.175.76.123:8000/WVUD-FM123.mp3'
fi

if cmd_exists jq
then
  jless() {
    # use jq to format & colorize json, then display it inside `less`
    if [ $# -lt 1 ]
    then
      # with no arguments, jless expects stdin to be json
      jq -C . | less -rN
    elif [ $# -lt 2 ]
    then
      # single argument: a file to view
      jq -C . "$1" | less -rN
    else
      # two arguments: the first is a file to read and the second is a jq pattern
      jq -C "$2" "$1" | less -rN
    fi
  }
fi

if cmd_exists curl
then
  # get approximate geo-location of IP from public API
  iploc() {
    if cmd_exists jq
    then
      # shellcheck disable=SC2086
      curl -s "https://ipinfo.io/$(dig $1 +short)" | jq .
    else
      # shellcheck disable=SC2086
      curl -s "https://ipinfo.io/$(dig $1 +short)"
    fi
  }
  # wikipedia summary
  wiki() {
    if [ $# -lt 1 ]
    then
      log "Usage: wiki <search string>" error
      return 1
    else
      curl -s -L -d "search=$1" https://en.wikipedia.org/w/index.php | w3m -T text/html -dump | less
    fi
  }
  alias headers='curl -sLD - -o /dev/null'
fi

# applies standard coloration for pager programs
less_color_env() {
  CMD=$1
  shift
  # shellcheck disable=SC2046
  env \
    LESS_TERMCAP_mb=$(printf "\\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\\e[0m") \
    LESS_TERMCAP_se=$(printf "\\e[0m") \
    LESS_TERMCAP_so=$(printf "\\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\\e[0m") \
    LESS_TERMCAP_us=$(printf "\\e[1;32m") \
      "$CMD" "$@"
}

alias man='less_color_env man'
alias pydoc2='less_color_env pydoc2'
alias pydoc='less_color_env pydoc'
alias less='less_color_env less'

histogram() {
  if [[ $# -lt 1 ]]
  then
    sort | uniq -c | sort -n
  elif [[ $# -lt 2 ]]
  then
    COL="\$$1"
    awk "{print $COL}" | sort | uniq -c | sort -n
  else
    COL="\$$1"
    awk -F"$2" "{print $COL}" | sort | uniq -c | sort -n
  fi
  return 0
}

license() {
  # get me a damn license!
  COMMAND="$1"
  declare -A LICENSES
  LICENSES=(
    ["gplv3"]="https://www.gnu.org/licenses/gpl-3.0.txt"
    ["agplv3"]="https://www.gnu.org/licenses/agpl-3.0.txt"
    ["lgplv3"]="https://www.gnu.org/licenses/lgpl-3.0.txt"
    ["apache"]="https://www.apache.org/licenses/LICENSE-2.0.txt"
    ["wtfpl"]="http://www.wtfpl.net/txt/copying/"
    ["mit"]="https://mit-license.org/license.txt"
    ["mozilla"]="https://www.mozilla.org/media/MPL/2.0/index.txt"
  )
  case $COMMAND in
    list)
      for k in "${!LICENSES[@]}"
      do
        echo "$k"
      done
      ;;
    get)
      if [ $# -lt 2 ]
      then
        log "license get requires an argument, the name of license to download" error
        return 1
      fi
      REQUEST="$2"
      if [[ "${LICENSES[$REQUEST]}" ]]
      then
        if hash curl
        then
          HTTP_METHOD="$(command -v curl) -s"
        elif hash wget
        then
          HTTP_METHOD="$(command -v wget) -O -"
        else
          log "Cannot find executables for curl or wget, install one" error
          return 1
        fi
        $HTTP_METHOD "${LICENSES[$REQUEST]}"
      else
        # shellcheck disable=SC2016
        log 'The argument you gave is not a recognized license name, try `license list`' error
      fi
      ;;
    help|*)
      echo "Commands:"
      echo "  list: list known licenses"
      echo "  get: download a license locally"
      echo "  help: view this help output"
      ;;
  esac
}

vimpipe() {
  vim "+w .vimpipe" - >/dev/tty; (cat .vimpipe; rm -f .vimpipe)
}

vimf() {
  # vim find!
  if [[ $# -lt 1 ]]; then
    echo "vimf needs at least one argument, the path to search for. Second argument specifies a directory"
    return 1
  fi
  PATTERN="$1"
  STARTPATH="${2:-.}"
  if hash fd >/dev/null; then
    # shellcheck disable=SC2046
    vim $(fd --full-path "$PATTERN" "$STARTPATH")
  else
    # shellcheck disable=SC2046
    vim $(find "$STARTPATH" -regextype grep -regex "$PATTERN")
  fi
}

serve() {
  IP=$(ifconfig | awk '/inet\ /{print $2}' | grep -v 127)
  echo "External IP $IP"
  PORT="${1:-8000}"
  DIR="${2:-.}"
  cd "$DIR"
  if hash python3; then
    python3 -m http.server "$PORT"
  elif hash python2; then
    python2 -m SimpleHTTPServer "$PORT"
  elif hash php; then
    php -S "127.0.0.1:${PORT}"
  elif hash busybox; then
    busybox httpd -f -p "$PORT"
  else
    python -m http.server "$PORT"
  fi
  cd - >/dev/null
}

flip-the-multitool() {
  case "$(uname -m)" in
    arm*)
      ARCH=arm
      ;;
    x86_64)
      ARCH=amd64
      ;;
    i386)
      ARCH=i386
      ;;
    aarch64)
      ARCH=arm64
      ;;
    default)
      log "Platform is not supported :(" err
      return 1
      ;;
  esac
  DOWNLOAD_URL=$(curl -s https://api.github.com/repos/delucks/multitool/releases/latest | grep browser_download_url | cut -d '"' -f 4 | grep "$(uname -s | tr '[:upper:]' '[:lower:]')_${ARCH}")
  mkdir -p ~/bin
  mkdir -p ~/.cache
  curl -sL "$DOWNLOAD_URL" > ~/.cache/multitool.tar.gz
  tar -C ~/bin -xvf ~/.cache/multitool.tar.gz
  ~/bin/multitool setup
}

if test -d "$HOME/go/"
then
  export GOPATH="$HOME/go"
  export GOBIN="$GOPATH/bin"
  pathappend "$GOPATH/bin"
fi
sourcep "$HOME/.localaliasrc"
pathappend "$HOME/.local/bin"
