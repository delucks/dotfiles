# common shell alias / functions
# author: delucks
# use freely, share and contribute

# common exports, sourcing functions
alias cmd_exists="hash >/dev/null 2>&1"
export LS_COLORS=
export LC_ALL="en_US.UTF-8"
if test -d "$HOME/dev/go/"
then
  export GOBIN="$HOME/dev/go/bin"
  export GOPATH="$HOME/dev/go"
fi
if cmd_exists vim
then
  export EDITOR='vim'
else
  export EDITOR='vi'
fi
if cmd_exists less
then
  export PAGER='less'
fi

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

# vc
if cmd_exists svn
then
  alias sch='svn checkout $@'
  alias sadd='svn add $@'
fi
if cmd_exists git
then
  alias gita='git add'
  alias gitd='git diff'
  alias gitc='git commit'
  alias gits='git status'
  alias gitl='git log --all --graph --pretty=format:"%Cred%h%Creset %C(bold blue)%an%Creset :%C(yellow)%d%Creset %s %Cgreen(%cr) %Creset"'
fi

# platform detection
if [[ "$OSTYPE" == "linux-gnu"* ]]
then
  # linux specific aliases
  test -d "${HOME}/GNUstep" && export GNUSTEP_USER_ROOT="${HOME}/GNUstep"
  #export TERM=xterm-256color
  alias lscan="sudo nmap -sP $(ip addr show | grep 'inet ' | grep global | awk '{print $2}') | grep -v -e Host\ is\ up -e done -e Starting"
  alias prdev="ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' '"
  alias paddr="ip addr show primary dev $(ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' ') | grep inet\ | awk '{print $2}'"
  alias ls='ls --color=auto'
  alias la='ls -aChkopl --group-directories-first --color=auto'
  if test -f /etc/debian_version
  then
    # debian specific
    alias packages="dpkg -l | awk '{$1=$3=$4=\",\"}1' | column -t -s,"
  elif cmd_exists pacman
  then
    # archlinux specific
    alias y='yaourt'
    alias orphan='pacman -Qtdq'
    sizes() {
    	awk 'BEGIN{while (("pacman -Qi" |getline) > 0){ if ($0 ~ /Name/) {name=$3};{if ($0 ~ /Size/) {size=$4/1024;print name": ",size,"Mb"|"sort -k2 -n|column -t"}}}}'
    }
    alias owner='pacman -Qo $(which $1)'
  fi
  cfat() {
  	sudo mount -t vfat /dev/sdb1 /mnt/vfat
  	log ok "Mounted."
  	sudo cp $@ /mnt/vfat/
  	log ok "Copied."
  	read -p "Press Enter to Unmount:"
  	sudo umount /mnt/vfat
  	log ok "Unmounted."
  }
  alias mfat='sudo mount -t vfat /dev/sdb1 /mnt/vfat'
  ununix() {
    date -d @$1
  }
elif [[ "$OSTYPE" == "darwin"* ]]
then
  # osx
  alias ls='ls -G'
  alias la='ls -aChGkopl --group-directories-first'
  alias lsg='ls -aChGkopl --group-directories-first | grep "$@"'
  alias ununix='date -r'
else
  alias la='ls -aChkopl --group-directories-first'
  alias lsg='ls -aChkopl --group-directories-first | grep "$@"'
fi

# beets
if cmd_exists beet
then
  alias bim='beet im'
  alias bls='beet ls'
  alias brm='beet remove'
  alias bvr='beet version'
fi

# procs
psgrep() {
	if [ $# -gt 0 ]; then
		ps -fp $(pgrep -f $1)
	else
		log fatal "Usage: psgrep <pattern to grep through processes for>"
    return 1
	fi
}

# herbsluftwm helpers
if cmd_exists herbstclient
then
  alias hkeys="cat ~/.config/herbstluftwm/autostart| egrep '^([\t\ ])?hc keybind' | awk '{print \$3}'"
  alias hmods="hkeys | grep mod | sed 's/\$mod\-//g' | sort"
  alias currtag="herbstclient tag_status | sed -e 's/[:|\.][a-zA-Z]//g' -e 's/[\t\ #]//g'"
  alias hc='herbstclient'
fi

# docker
if cmd_exists docker
then
  docker-remove() {
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi 2>&1 | awk '{print $12}' | uniq | xargs sudo docker rm
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi
  }
  alias daddr="sudo docker ps | tail -1 | awk '{print $1}' | xargs sudo docker inspect -f '{{.NetworkSettings}}' "
fi

# networking
alias router="routel | egrep '^\ +default' | grep -v lo | awk '{print $2}'"
alias ssh-hosts="grep 'Host\ ' $HOME/.ssh/config | awk '{print \$NF}'"

# misc
alias sx='ssh-agent startx'
alias ts='while read line; do date +"%F %T $line"; done'
alias ks='killall spotify'
alias cdiff='dwdiff --no-common -c'
alias big="echo $1 | figlet"
alias \:q='exit'
alias strings='strings -a'
alias trace='mtr -rw4 -c 5'
alias whereami='uname -n'
alias d='date +%R'
alias violet='wmname LG3D && violet'
alias wgot='wget -e robots=off -r -nc -np '
alias rot13='tr "a-zA-Z" "n-za-mN-ZA-M"'
alias iploc='curl ipinfo.io/$(dig $1 +short)'
alias mkdir='mkdir -p'
alias datehelp='for F in {a..z} {A..Z} :z ::z :::z;do echo $F: $(date +%$F);done|sed "/:[\ \t\n]*$/d;/%[a-zA-Z]/d"'
alias serve='python2 -m SimpleHTTPServer'
alias apropy="pydoc -k $1 2>/dev/null"
alias apropos="man -k" # yeah, some platforms don't do this
alias count='sort | uniq -c | sort -nr'
alias csvify="tr '\n' ',' | sed 's/,$//g'"
alias meh='echo "¯\_(ツ)_/¯"'

if cmd_exists tmux
then
  alias tmuxa='tmux a'
  gomux() {
    if [ $# -lt 1 ]
    then
      log err 'gomux requires at least one argument, a session name'
      return 1
    elif [ $# -lt 2 ]
    then
      # do the one-arg thing
      tmux new-session -A -s "$1"
    else
      # add the command name into it
      tmux new-session -A -s "$1" "$2"
    fi
  }
fi



if cmd_exists mencoder
then
  alias flvjoin='mencoder -forceidx -of lavf -oac pcm -ovc copy -o output.flv '
fi
if cmd_exists mplayer
then
  say() {
  	if [[ "${1}" =~ -[a-z]{2} ]]; then
  		local lang=${1#-};
  		local text="${*#$1}";
  	else 
  		local lang=${LANG%_*};
  		local text="$*";
  	fi;
  	mplayer "http://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&q=${text}" &> /dev/null ;
  }
  alias wvud='mplayer http://128.175.76.123:8000/WVUD-FM123.mp3'
  alias webcam='mplayer tv:// -tv driver=v4l2:width=640:height=480:device=/dev/video0 -fps 15 -vf screenshot'
fi

# functions 

initializeANSI()
{
  esc="\033"
  blackf="${esc}[0;30m"
  redf="${esc}[0;31m"
  greenf="${esc}[0;32m"
  yellowf="${esc}[0;33m"
  bluef="${esc}[0;34m"
  purplef="${esc}[0;35m"
  cyanf="${esc}[0;36m"
  whitef="${esc}[0;37m"
  blackb="${esc}[0;40m"
  redb="${esc}[0;41m"
  greenb="${esc}[0;42m"
  yellowb="${esc}[0;43m"
  blueb="${esc}[0;44m"
  purpleb="${esc}[0;45m"
  cyanb="${esc}[0;46m"
  whiteb="${esc}[0;47m"
  boldon="${esc}[0;1m"
  boldoff="${esc}[0;22m"
  italicson="${esc}[0;3m"
  italicsoff="${esc}[0;23m"
  ulon="${esc}[0;4m"
  uloff="${esc}[0;24m"
  invon="${esc}[0;7m"
  invoff="${esc}[0;27m"
  reset="${esc}[0m"
}
initializeANSI

log() {
  if [ $# -gt 1 ]
  then
    if [[ "$1" == "err"* ]]
    then
      shift
      echo -e "${redf}$@${reset}"
    elif [[ "$1" == "ok"* ]]
    then
      shift
      echo -e "${greenf}$@${reset}"
    elif [[ "$1" == "warn"* ]]
    then
      shift
      echo -e "${yellowf}$@${reset}"
    elif [[ "$1" == "fatal"* ]]
    then
      shift
      echo -e "${redf}$@${reset}"
      return 1
    else
      shift
      echo -e "$@"
    fi
  else
    echo -e "$@"
  fi
}

jless() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: jless <json file> [<jq pattern>]"
  elif [ $# -lt 2 ]
  then
    jq -C . $1 | less -r
  else
    jq -C $2 $1 | less -r
  fi
}

if test -f "$HOME/scripts/x86.py"
then
  x86() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: x86 <opcode>"
      return 1
    else
      python "$HOME/scripts/x86.py" $1 | lynx -stdin -dump
    fi
  }
fi

hex() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: hex <integer to convert>"
    return 1
  else
    python -c "print hex($1)"
  fi
}

int() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: int <hexadecimal to convert>"
    return 1
  else
    python -c "print int('$1',16)"
  fi
}

# wikipedia summary
if cmd_exists curl
then
  function wiki {
  	if [ $# -lt 1 ]
    then
      log fatal "Usage: wiki <search string>"
      return 1
    else
      curl -s -L -d "search=$1" https://en.wikipedia.org/w/index.php | w3m -T text/html -dump | less
  	fi
  }
fi

# intel-specific brightness
if test -f /sys/class/backlight/intel_backlight/brightness
then
  b() {
  	if [ $# -eq 0 ]; then
  		cat /sys/class/backlight/intel_backlight/brightness
    elif [[ "$1" -eq "max" ]]; then
      echo "$(cat /sys/class/backlight/intel_backlight/max_brightness)" | sudo tee -a /sys/class/backlight/intel_backlight/brightness
    else
  		echo "${1}" | sudo tee -a /sys/class/backlight/intel_backlight/brightness
  	fi
  }
fi

# asus-specific keyboard brightness control
if test -f /sys/class/leds/asus::kbd_backlight/brightness
then
  kb() {
    echo "$1" | sudo tee  /sys/class/leds/asus::kbd_backlight/brightness
  }
fi

# cd and ls at once
cl() {
	if [ -d "$1" ]; then
		cd "$1"
		ls
	else
		log fatal "cl(): $1: Directory not found"
	fi
}

mkcd() {
  mkdir -p "$1"
  cd "$1"
}

# applies standard coloration for pager programs
less_color_env() {
  CMD=$1
  shift
	env \
		LESS_TERMCAP_mb=$(printf "\e[1;31m") \
		LESS_TERMCAP_md=$(printf "\e[1;31m") \
		LESS_TERMCAP_me=$(printf "\e[0m") \
		LESS_TERMCAP_se=$(printf "\e[0m") \
		LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
		LESS_TERMCAP_ue=$(printf "\e[0m") \
		LESS_TERMCAP_us=$(printf "\e[1;32m") \
			$CMD "$@"
}

alias man='less_color_env man'
alias pydoc2='less_color_env pydoc2'
alias pydoc='less_color_env pydoc'
alias less='less_color_env less'

# common valgrind usages
if cmd_exists valgrind
then
  alias memcheck='valgrind --tool=memcheck $@ --leak-check=full'
  valhalla() {
  	if [ "$#" == "0" ]; then
  		make
  		valgrind --tool=memcheck ./*.exe --leak-check=full
  	else
  		g++ -g "$1" -o "$(basename $1).out" && valgrind --tool=memcheck ./"$(basename $1).out" "${@:2}" --leak-check=full
  	fi
  }
fi

# recursive grep...
rgrep() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rgrep <pattern> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack $1 "$SEARCH_PATH"
    else
      grep -riIE $1 "$SEARCH_PATH" | grep -v \.svn | grep -v \.git
    fi
  fi
}

# ...and find...
rfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rfind <string to find> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack -g "$1" "$SEARCH_PATH"
    else
      find "$SEARCH_PATH" -name "*$1*"
    fi
  fi
}

# ...with vim!
vfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: vfind <string to find> <starting directory>"
    return 1
  else
    vim $(rfind "$@")
  fi
}

alias rg='rgrep'
alias rf='rfind'
alias vf='vfind'

if test -d "$HOME/notes/"
then
  note() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: note <name of note>"
      exit 1
    fi
  	FILE="$HOME/notes/$1.txt"
  	if [ -f $FILE ];
  	then
  		log ok "$FILE exists"
  		vim "$FILE"
  	else
  		touch "$FILE"
  		echo "$1" | figlet > "$FILE"
  		echo "Note from $(date)" >> "$FILE"
  		vim "$FILE"
  	fi
  }
fi

ccd() {
  if [ $# -lt 2 ]
  then
    log fatal "Usage: ccd <file to copy> <directory to copy into>"
    return 1
  fi
	FILE="$1"
	if [ ! -f "$FILE" ];
	then
		log fatal "File not found"
		return 1
	fi
	DIR="$2"
	if [ ! -d "$DIR" ];
	then
		log fatal "Dir not found"
		return 1
	fi
	cp -r "$FILE" "$DIR"
	cd "$DIR"
	pwd
}

# add a directory to path, but only if it exists
# and if it's not already in path
addp() {
  if [ $# -lt 1 ]
  then
    log fatal 'Usage: addp <path to add to $PATH>'
    return 1
  fi
  if [[ -d "$1" ]]
  then
    case $1 in
      */)
        TRIMMED=$(echo "$1" | sed 's/\/$//g')
        [[ "$PATH" == *"$TRIMMED:"* ]] || export PATH="$TRIMMED:$PATH"
        ;;
      *)
        [[ "$PATH" == *"$1:"* ]] || export PATH="$1:$PATH"
        ;;
    esac
    return 0
  fi
  #log err "Path unavailable"
  return 1
}

# source a file, but only if it exists
sourcep() {
  if [[ $# -lt 1 ]]
  then
    log fatal "Usage: sourcep <path to source>"
    return 1
  fi
  if [[ -f "$1" ]]
  then
    source "$1"
    return 0
  fi
  #echo "Path unavailable"
  return 1
}

silent() {
  if [ $# -lt 1 ];
  then
    log fatal "Usage: silent <command to run>"
    return 1
  fi
  eval "$1 2>/dev/null 1>&2"
}

stdfile() {
  if [ $# -lt 1 ];
  then
    log fatal "Usage: stdfile <command to redirect stout and stderr to separate files over>"
    return 1
  fi
  eval "$1 2>./stderr 1>./stdout"
}

# use it like scp!
lss() {
  H=$(echo $1 | awk -F':' '{print $1}')
  F=$(echo $1 | awk -F':' '{print $2}')
  /usr/bin/ssh $H "ls $F"
}

histogram() {
  if [[ $# -lt 1 ]]
  then     
    # changed 2016-02-21: this is useful default behavior
    sort | uniq -c | sort -n
  elif [[ $# -lt 2 ]]
  then
    COL="\$$1"
    awk "{print $COL}" | sort | uniq -c | sort -n
  else
    COL="\$$1"
    awk -F"$2" "{print $COL}" | sort | uniq -c | sort -n
  fi
  return 0
}

lsfunc() {
  typeset -F | awk '{print $NF}'
}

isgit() {
  [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1
}

issvn() {
  svn info >/dev/null 2>&1
}

# wraps version control software
vc() {
  command=${1:-"status"}
  case "${command}" in
    status)
      isgit && git status
      issvn && svn status
      ;;
    up)
      isgit && git pull
      issvn && svn update
      ;;
    push)
      isgit && git push
      issvn && svn commit
      ;;
    *)
      log fatal "Usage: vc <status|up|push>"
      return 1
  esac
}

# expand my environment pls
sourcep "$HOME/ansible/hacking/env-setup"
sourcep "$HOME/.localaliasrc"
addp "$HOME/dev/go/bin"
addp "$HOME/scripts"
addp "$HOME/bin"
addp "$HOME/.gem/ruby/2.1.0/bin"
