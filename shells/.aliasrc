# common shell alias / functions
# author: delucks
# use freely, share and contribute
# vi:syntax=sh

# common exports, sourcing functions
alias cmd_exists="hash >/dev/null 2>&1"
export LS_COLORS=
export LC_ALL="en_US.UTF-8"
if cmd_exists vim
then
  export EDITOR='vim'
else
  export EDITOR='vi'
fi
export PAGER='less'

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

if cmd_exists git
then
  alias gita='git add'
  alias gitd='git diff'
  alias gits='git status'
  alias gitl='git log --all --graph --pretty=format:"%Cred%h%Creset %C(bold blue)%an%Creset :%C(yellow)%d%Creset %s %Cgreen(%cr) %Creset"'
  alias gitp='git push origin master'
fi

# platform detection
if [[ "$OSTYPE" == "linux-gnu"* ]]
then
  # linux specific aliases
  alias ls='ls --color=auto'
  alias la='ls -aChkopl --group-directories-first --color=auto'
  alias errno="grep '#define' /usr/include/asm-generic/errno.h"
  if test -f /etc/debian_version
  then
    # debian specific
    alias packages="dpkg -l | awk '{$1=$3=$4=\",\"}1' | column -t -s,"
    alias ack="ack-grep"
  elif cmd_exists pacman
  then
    # archlinux specific
    alias y='yaourt'
    alias orphan='pacman -Qtdq'
    sizes() {
      awk 'BEGIN{while (("pacman -Qi" |getline) > 0){ if ($0 ~ /Name/) {name=$3};{if ($0 ~ /Size/) {size=$4/1024;print name": ",size,"Mb"|"sort -k2 -n|column -t"}}}}'
    }
    alias owner='pacman -Qo $(which $1)'
  fi
  ununix() {
    date -d @$1
  }
  alias suspend='pm-suspend'  # I don't care about suspending my shell, what is this, 1980?
elif [[ "$OSTYPE" == "darwin"* ]]
then
  # osx
  alias ls='ls -G'
  alias la='ls -aChGkopl --group-directories-first'
  alias lsg='ls -aChGkopl --group-directories-first | grep "$@"'
  alias ununix='date -r'
  alias errno="grep '#define' /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h"
else
  alias la='ls -aChkopl --group-directories-first'
  alias lsg='ls -aChkopl --group-directories-first | grep "$@"'
fi

# beets
if cmd_exists beet
then
  alias bim='beet im'
  alias bls='beet ls'
  alias brm='beet remove'
fi

# This adds an argument to BSD paste to accept stdin by default
# The only use case I have for paste is joining standard input
mypaste() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]
  then
    paste "$@"
  else
    paste "$@" -
  fi
}
alias paste=mypaste

# procs
psgrep() {
  if [ $# -gt 0 ]; then
    ps up $(pgrep -f $1)
  else
    log fatal "Usage: psgrep <pattern to grep through processes for>"
    return 1
  fi
}

# herbsluftwm helpers
if cmd_exists herbstclient
then
  alias hkeys="cat $HOME/.config/herbstluftwm/autostart| egrep '^([\t\ ])?hc keybind' | awk '{print \$3}'"
  alias hmods="hkeys | grep mod | sed 's/\$mod\-//g' | sort"
  alias currtag="herbstclient tag_status | sed -e 's/[:|\.][a-zA-Z]//g' -e 's/[\t\ #]//g'"
  alias hc='herbstclient'
fi

# networking
alias router="routel | egrep '^\ +default' | grep -v lo | awk '{print $2}'"

ssh-hosts() {
  awk '/Host\ /{print $NF}' $HOME/.ssh/config
}

logmein() {
  HOSTS=$(grep -E "Host\ .*$1" $HOME/.ssh/config | awk '{print $NF}')
  echo "$HOSTS" | while read hostname; do
    echo "exit" | ssh $hostname
  done
}

# misc
alias sx='ssh-agent startx'
alias ts='while read line; do date +"%F %T $line"; done'
alias ks='killall spotify'
alias cdiff='dwdiff --no-common -c'
alias big="echo $1 | figlet -t"
alias \:q='exit'
alias strings='strings -a'
alias trace='mtr -rw4 -c 5'
alias whereami='echo "$(uname -n) in $(pwd)"'
alias d='date +%R'
alias violet='wmname LG3D && violet'
alias wgot='wget -e robots=off -r -nc -np '
alias rot13='tr "a-zA-Z" "n-za-mN-ZA-M"'
alias mkdir='mkdir -p'
alias datehelp='for F in {a..z} {A..Z} :z ::z :::z;do echo $F: $(date +%$F);done|sed "/:[\ \t\n]*$/d;/%[a-zA-Z]/d"'
alias ve='source bin/activate'
alias apropy="pydoc -k $1 2>/dev/null"
alias apropos="man -k" # yeah, some platforms don't do this
alias csvify="tr '\n' ',' | sed 's/,$//g'"
alias meh='echo "¯\_(ツ)_/¯"'
alias whom='who'
alias tmuxa='tmux a'
alias sl='ls'

if cmd_exists netctl
then
  netctlgrep() {
    netctl list | grep -E "$1" | awk '{print $NF}' | xargs sudo netctl start
  }
fi

if cmd_exists mencoder
then
  alias flvjoin='mencoder -forceidx -of lavf -oac pcm -ovc copy -o output.flv '
fi
if cmd_exists mplayer
then
  say() {
    if [[ "${1}" =~ -[a-z]{2} ]]; then
      local lang=${1#-};
      local text="${*#$1}";
    else
      local lang=${LANG%_*};
      local text="$*";
    fi;
    mplayer "http://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&q=${text}" &> /dev/null ;
  }
  alias wvud='mplayer http://128.175.76.123:8000/WVUD-FM123.mp3'
  alias webcam='mplayer tv:// -tv driver=v4l2:width=640:height=480:device=/dev/video0 -fps 15 -vf screenshot'
fi

# functions

initializeANSI()
{
  blackf="$(tput setaf 0)"
  redf="$(tput setaf 1)"
  greenf="$(tput setaf 2)"
  yellowf="$(tput setaf 3)"
  bluef="$(tput setaf 4)"
  purplef="$(tput setaf 5)"
  cyanf="$(tput setaf 6)"
  whitef="$(tput setaf 7)"
  boldon="$(tput bold)"
  italicson="$(tput sitm)"
  ulon="$(tput smul)"
  reset="$(tput sgr0)"
}
initializeANSI

log() {
  # if the first argument is a recognized log level, output everything else with color
  if [ $# -gt 1 ]
  then
    case "$1" in
      err*)
        shift
        echo -e "[ERROR] ${redf}$@${reset}"
        ;;
      info*|ok*)
        shift
        echo -e "[INFO]  ${greenf}$@${reset}"
        ;;
      warn*)
        shift
        echo -e "[WARN]  ${yellowf}$@${reset}"
        ;;
      fatal*)
        shift
        echo -e "[FATAL] ${redf}$@${reset}"
        return 1
        ;;
      *)
        echo -e "$@"
        ;;
    esac
  else
    echo -e "$@"
  fi
}

if cmd_exists jq
then
  jless() {
    # use jq to format & colorize json, then display it inside `less`
    if [ $# -lt 1 ]
    then
      # with no arguments, jless expects stdin to be json
      jq -C . | less -rN
    elif [ $# -lt 2 ]
    then
      # single argument: a file to view
      jq -C . $1 | less -rN
    else
      # two arguments: the first is a file to read and the second is a jq pattern
      jq -C $2 $1 | less -rN
    fi
  }
fi

if test -f "$HOME/scripts/x86.py"
then
  x86() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: x86 <opcode>"
      return 1
    else
      python "$HOME/scripts/x86.py" $1 | lynx -stdin -dump
    fi
  }
fi

hex() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: hex <integer to convert>"
    return 1
  else
    python -c "print hex($1)"
  fi
}

int() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: int <hexadecimal to convert>"
    return 1
  else
    python -c "print int('$1',16)"
  fi
}

# wikipedia summary
if cmd_exists curl
then
  iploc() {
    if cmd_exists jq
    then
      curl -s "https://ipinfo.io/$(dig $1 +short)" | jq .
    else
      curl -s "https://ipinfo.io/$(dig $1 +short)"
    fi
  }
  function wiki {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: wiki <search string>"
      return 1
    else
      curl -s -L -d "search=$1" https://en.wikipedia.org/w/index.php | w3m -T text/html -dump | less
    fi
  }
  alias headers='curl -sLD - -o /dev/null'
  alias emoji='curl -s "https://www.unicode.org/Public/emoji/11.0/emoji-data.txt" | grep -vE "^#"'
fi

# brightness
b() {
  OPTIONS=(/sys/class/backlight/acpi_video0 /sys/class/backlight/intel_backlight /sys/class/backlight/backlight.12)
  for i in "${OPTIONS[@]}"
  do
    if test -d "$i"; then
      echo "using $i"
      SYS_DIR="$i"
    fi
  done
  if [ $# -eq 0 ]; then
    cat "$SYS_DIR/brightness"
  elif [[ "$1" -eq "max" ]]; then
    cat "$SYS_DIR/max_brightness" | sudo tee "$SYS_DIR/brightness"
  else
    echo "${1}" | sudo tee "$SYS_DIR/brightness"
  fi
}

# asus-specific keyboard brightness control
if test -f /sys/class/leds/asus::kbd_backlight/brightness
then
  kb() {
    echo "$1" | sudo tee  /sys/class/leds/asus::kbd_backlight/brightness
  }
fi

# cd and ls at once
cl() {
  if [ -d "$1" ]; then
    cd "$1"
    ls
  else
    log fatal "cl(): $1: Directory not found"
  fi
}

mkcd() {
  mkdir -p "$1" && cd "$1"
}

# applies standard coloration for pager programs
less_color_env() {
  CMD=$1
  shift
  env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
      $CMD "$@"
}

alias man='less_color_env man'
alias pydoc2='less_color_env pydoc2'
alias pydoc='less_color_env pydoc'
alias less='less_color_env less'

# common valgrind usages
if cmd_exists valgrind
then
  alias memcheck='valgrind --tool=memcheck $@ --leak-check=full'
  valhalla() {
    if [ "$#" == "0" ]; then
      make
      valgrind --tool=memcheck ./*.exe --leak-check=full
    else
      g++ -g "$1" -o "$(basename $1).out" && valgrind --tool=memcheck ./"$(basename $1).out" "${@:2}" --leak-check=full
    fi
  }
fi

# recursive grep...
rgrep() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rgrep <pattern> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack $1 "$SEARCH_PATH"
    else
      grep -riIE $1 "$SEARCH_PATH" | grep -v \.svn | grep -v \.git
    fi
  fi
}

# ...and find...
rfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rfind <string to find> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack -g "$1" "$SEARCH_PATH"
    else
      find "$SEARCH_PATH" -name "*$1*"
    fi
  fi
}
alias rf='rfind'

# ...with vim!
vfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: vfind <string to find> <starting directory>"
    return 1
  else
    vim $(rfind "$@")
  fi
}

if test -d "$HOME/notes/"
then
  note() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: note <name of note>"
      return 1
    fi
    FILE="$HOME/notes/$1.txt"
    if [ -f $FILE ];
    then
      log ok "$FILE exists"
      vim "$FILE"
    else
      touch "$FILE"
      echo "$1" | figlet > "$FILE"
      echo "Note from $(date)" >> "$FILE"
      vim "$FILE"
    fi
  }
fi

ccd() {
  if [ $# -lt 2 ]
  then
    log fatal "Usage: ccd <file to copy> <directory to copy into>"
    return 1
  fi
  FILE="$1"
  if [ ! -f "$FILE" ];
  then
    log fatal "File not found"
    return 1
  fi
  DIR="$2"
  if [ ! -d "$DIR" ];
  then
    log fatal "Dir not found"
    return 1
  fi
  cp -r "$FILE" "$DIR"
  cd "$DIR"
  pwd
}

# add a directory to path, but only if it exists
# and if it's not already in path
addp() {
  if [ $# -lt 1 ]
  then
    log fatal 'Usage: addp <path to add to $PATH>'
    return 1
  fi
  if [[ -d "$1" ]]
  then
    case $1 in
      */)
        TRIMMED=$(echo "$1" | sed 's/\/$//g')
        [[ "$PATH" == *"$TRIMMED:"* ]] || PATH="$TRIMMED:$PATH"
        ;;
      *)
        [[ "$PATH" == *"$1:"* ]] || PATH="$1:$PATH"
        ;;
    esac
    return 0
    PATH=$(echo "$PATH" | awk -v RS=':' -v ORS=":" '!a[$1]++{if (NR > 1) printf ORS; printf $a[$1]}')
  fi
  #log err "Path unavailable"
  return 1
}

# source a file, but only if it exists
sourcep() {
  if [[ $# -lt 1 ]]
  then
    log fatal "Usage: sourcep <path to source>"
    return 1
  fi
  if [[ -f "$1" ]]
  then
    source "$1"
    return 0
  fi
  #echo "Path unavailable"
  return 1
}

silent() {
  if [ $# -lt 1 ];
  then
    log fatal "Usage: silent <command to run>"
    return 1
  fi
  eval "$1 2>/dev/null 1>&2"
}

# use it like scp!
lss() {
  H=$(echo $1 | awk -F':' '{print $1}')
  F=$(echo $1 | awk -F':' '{print $2}')
  /usr/bin/ssh $H "ls $F"
}

histogram() {
  if [[ $# -lt 1 ]]
  then
    # changed 2016-02-21: this is useful default behavior
    sort | uniq -c | sort -n
  elif [[ $# -lt 2 ]]
  then
    COL="\$$1"
    awk "{print $COL}" | sort | uniq -c | sort -n
  else
    COL="\$$1"
    awk -F"$2" "{print $COL}" | sort | uniq -c | sort -n
  fi
  return 0
}

lsfunc() {
  typeset -F | awk '{print $NF}'
}

isgit() {
  [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1
}

issvn() {
  svn info >/dev/null 2>&1
}

# wraps version control software
vc() {
  command=${1:-"status"}
  case "${command}" in
    status)
      isgit && git status
      issvn && svn status
      ;;
    up)
      isgit && git pull
      issvn && svn update
      ;;
    push)
      isgit && git push
      issvn && svn commit
      ;;
    *)
      log fatal "Usage: vc <status|up|push>"
      return 1
  esac
}

license() {
  # get me a damn license!
  COMMAND="$1"
  declare -A LICENSES
  LICENSES=(
    ["gplv3"]="https://www.gnu.org/licenses/gpl-3.0.txt"
    ["agplv3"]="https://www.gnu.org/licenses/agpl-3.0.txt"
    ["lgplv3"]="https://www.gnu.org/licenses/lgpl-3.0.txt"
    ["apache"]="https://www.apache.org/licenses/LICENSE-2.0.txt"
    ["wtfpl"]="http://www.wtfpl.net/txt/copying/"
    ["mit"]="https://mit-license.org/license.txt"
    ["mozilla"]="https://www.mozilla.org/media/MPL/2.0/index.txt"
  )
  case $COMMAND in
    list)
      for k in "${!LICENSES[@]}"
      do
        echo "$k"
      done
      ;;
    get)
      if [ $# -lt 2 ]
      then
        log err "license get requires an argument, the name of license to download"
        return 1
      fi
      REQUEST="$2"
      if [[ "${LICENSES[$REQUEST]}" ]]
      then
        if hash curl
        then
          HTTP_METHOD="$(which curl) -s"
        elif hash wget
        then
          HTTP_METHOD="$(which wget) -O -"
        else
          log err "Cannot find executables for curl or wget, install one"
          return 1
        fi
        $HTTP_METHOD "${LICENSES[$REQUEST]}"
      else
        log err 'The argument you gave is not a recognized license name, try `license list`'
      fi
      ;;
    help|*)
      echo "Commands:"
      echo "  list: list known licenses"
      echo "  get: download a license locally"
      echo "  help: view this help output"
      ;;
  esac
}

sudo_with_confirmation() {
  echo "This program would like to use your elevated privileges to run the following command:"
  echo
  echo "$@"
  echo
  echo 'Is this ok?'
  select confirmation in "Yes" "No"; do
    case "$confirmation" in
      Yes )
        sudo $@
        return $?
        ;;
      No )
        echo 'Not executing, bailing out'
        return 1
        ;;
    esac
  done
}

witch() {
  which "$1" 2> /dev/null || typeset -f "$1" || alias "$1" 2> /dev/null || echo "$1 not found"
}

vims() {
  if [ -f Session.vim ]; then
    vim -S
  elif [[ $# -ge 1 ]]; then
    vim $(find . -name "$1")
  else
    vim $(find . -name "*.py")
  fi
}

serve() {
  PORT="${1:-8000}"
  if hash python3; then
    python3 -m http.server $PORT
  elif hash python2; then
    python2 -m SimpleHTTPServer $PORT
  elif hash php; then
    php -S "127.0.0.1:${PORT}"
  elif hash busybox; then
    busybox httpd -f -p $PORT
  else
    python -m http.server $PORT
  fi
}

if cmd_exists inotifywait; then
  onchange() {
    # Look for filesystem events using inotify, run command if they change
    if [[ $# -lt 1 ]]; then
      log fatal "Usage: changed <command to run> [file or dir, defaults to .]"
      return 1
    fi
    COMMAND="$1"
    DIR="${2:-.}"
    inotifywait -mr -e modify -e move -e create -e delete --exclude ".git|.swp|.swx" "$DIR" | while read line; do
      eval "$COMMAND"
    done
  }
fi

# expand my environment pls
if test -d "$HOME/dev/go/"
then
  export GOBIN="$HOME/dev/go/bin"
  addp "$HOME/dev/go/bin"
  export GOPATH="$HOME/dev/go"
fi
sourcep "$HOME/.localaliasrc"
addp "$HOME/scripts"
addp "$HOME/bin"
addp "$HOME/.local/bin"
