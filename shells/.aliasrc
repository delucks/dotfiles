# common shell alias / functions
# author: delucks
# use freely, share and contribute
# vi:syntax=sh

# common exports, sourcing functions
alias cmd_exists="hash >/dev/null 2>&1"
export LS_COLORS=
export LC_ALL="en_US.UTF-8"
if cmd_exists vim
then
  export EDITOR='vim'
else
  export EDITOR='vi'
fi
if cmd_exists less
then
  export PAGER='less'
fi

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

# vc
if cmd_exists svn
then
  alias sch='svn checkout $@'
  alias sadd='svn add $@'
fi
if cmd_exists git
then
  alias gita='git add'
  alias gitd='git diff'
  alias gits='git status'
  alias gitl='git log --all --graph --pretty=format:"%Cred%h%Creset %C(bold blue)%an%Creset :%C(yellow)%d%Creset %s %Cgreen(%cr) %Creset"'
  alias giti='git info'
  alias gitp='git push origin master'
fi

# platform detection
if [[ "$OSTYPE" == "linux-gnu"* ]]
then
  # linux specific aliases
  test -d "${HOME}/GNUstep" && export GNUSTEP_USER_ROOT="${HOME}/GNUstep"
  #export TERM=xterm-256color
  alias lscan="sudo nmap -sP $(ip addr show | grep 'inet ' | grep global | awk '{print $2}') | grep -v -e Host\ is\ up -e done -e Starting"
  alias prdev="ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' '"
  alias paddr="ip addr show primary dev $(ip link show up | grep mtu | grep -v lo | awk -F':' '{print $2}' | tr -d ' ') | grep inet\ | awk '{print $2}'"
  alias ls='ls --color=auto'
  alias la='ls -aChkopl --group-directories-first --color=auto'
  if test -f /etc/debian_version
  then
    # debian specific
    alias packages="dpkg -l | awk '{$1=$3=$4=\",\"}1' | column -t -s,"
    alias ack="ack-grep"
  elif cmd_exists pacman
  then
    # archlinux specific
    alias y='yaourt'
    alias orphan='pacman -Qtdq'
    sizes() {
    	awk 'BEGIN{while (("pacman -Qi" |getline) > 0){ if ($0 ~ /Name/) {name=$3};{if ($0 ~ /Size/) {size=$4/1024;print name": ",size,"Mb"|"sort -k2 -n|column -t"}}}}'
    }
    alias owner='pacman -Qo $(which $1)'
  fi
  cfat() {
  	sudo mount -t vfat /dev/sdb1 /mnt/vfat
  	log ok "Mounted."
  	sudo cp $@ /mnt/vfat/
  	log ok "Copied."
  	read -p "Press Enter to Unmount:"
  	sudo umount /mnt/vfat
  	log ok "Unmounted."
  }
  alias mfat='sudo mount -t vfat /dev/sdb1 /mnt/vfat'
  ununix() {
    date -d @$1
  }
elif [[ "$OSTYPE" == "darwin"* ]]
then
  # osx
  alias ls='ls -G'
  alias la='ls -aChGkopl --group-directories-first'
  alias lsg='ls -aChGkopl --group-directories-first | grep "$@"'
  alias ununix='date -r'
else
  alias la='ls -aChkopl --group-directories-first'
  alias lsg='ls -aChkopl --group-directories-first | grep "$@"'
fi

# beets
if cmd_exists beet
then
  alias bim='beet im'
  alias bls='beet ls'
  alias brm='beet remove'
  alias bvr='beet version'
fi

# procs
psgrep() {
	if [ $# -gt 0 ]; then
		ps -fp $(pgrep -f $1)
	else
		log fatal "Usage: psgrep <pattern to grep through processes for>"
    return 1
	fi
}

# herbsluftwm helpers
if cmd_exists herbstclient
then
  alias hkeys="cat $HOME/.config/herbstluftwm/autostart| egrep '^([\t\ ])?hc keybind' | awk '{print \$3}'"
  alias hmods="hkeys | grep mod | sed 's/\$mod\-//g' | sort"
  alias currtag="herbstclient tag_status | sed -e 's/[:|\.][a-zA-Z]//g' -e 's/[\t\ #]//g'"
  alias hc='herbstclient'
fi

# docker
if cmd_exists docker
then
  docker-remove() {
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi 2>&1 | awk '{print $12}' | uniq | xargs sudo docker rm
    sudo docker images | grep "$1" | awk '{print $3}' | xargs sudo docker rmi
  }
  alias daddr="sudo docker ps | tail -1 | awk '{print $1}' | xargs sudo docker inspect -f '{{.NetworkSettings}}' "
fi

# networking
alias router="routel | egrep '^\ +default' | grep -v lo | awk '{print $2}'"
alias ssh-hosts="grep 'Host\ ' $HOME/.ssh/config | awk '{print \$NF}'"
logmein() {
  HOSTS=$(grep -E "Host\ .*$1" $HOME/.ssh/config | awk '{print $NF}')
  echo "$HOSTS" | while read hostname; do
    echo "exit" | ssh $hostname
  done
}

# misc
alias sx='ssh-agent startx'
alias ts='while read line; do date +"%F %T $line"; done'
alias ks='killall spotify'
alias cdiff='dwdiff --no-common -c'
alias big="echo $1 | figlet"
alias \:q='exit'
alias strings='strings -a'
alias trace='mtr -rw4 -c 5'
alias whereami='echo "$(uname -n) in $(pwd)"'
alias d='date +%R'
alias violet='wmname LG3D && violet'
alias wgot='wget -e robots=off -r -nc -np '
alias rot13='tr "a-zA-Z" "n-za-mN-ZA-M"'
alias iploc='curl ipinfo.io/$(dig $1 +short)'
alias mkdir='mkdir -p'
alias datehelp='for F in {a..z} {A..Z} :z ::z :::z;do echo $F: $(date +%$F);done|sed "/:[\ \t\n]*$/d;/%[a-zA-Z]/d"'
alias serve='python2 -m SimpleHTTPServer'
alias ve='source bin/activate'
alias apropy="pydoc -k $1 2>/dev/null"
alias apropos="man -k" # yeah, some platforms don't do this
alias count='sort | uniq -c | sort -nr'
alias csvify="tr '\n' ',' | sed 's/,$//g'"
alias meh='echo "¯\_(ツ)_/¯"'
alias whom='who'

if cmd_exists netctl
then
  netctlgrep() {
    netctl list | grep -E "$1" | awk '{print $NF}' | xargs sudo netctl start
  }
fi

if cmd_exists tmux
then
  alias tmuxa='tmux a'
  gomux() {
    if [ $# -lt 1 ]
    then
      log err 'gomux requires at least one argument, a session name'
      return 1
    elif [ $# -lt 2 ]
    then
      # do the one-arg thing
      tmux new-session -A -s "$1"
    else
      # add the command name into it
      tmux new-session -A -s "$1" "$2"
    fi
  }
fi



if cmd_exists mencoder
then
  alias flvjoin='mencoder -forceidx -of lavf -oac pcm -ovc copy -o output.flv '
fi
if cmd_exists mplayer
then
  say() {
  	if [[ "${1}" =~ -[a-z]{2} ]]; then
  		local lang=${1#-};
  		local text="${*#$1}";
  	else 
  		local lang=${LANG%_*};
  		local text="$*";
  	fi;
  	mplayer "http://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&q=${text}" &> /dev/null ;
  }
  alias wvud='mplayer http://128.175.76.123:8000/WVUD-FM123.mp3'
  alias webcam='mplayer tv:// -tv driver=v4l2:width=640:height=480:device=/dev/video0 -fps 15 -vf screenshot'
fi

# functions 

initializeANSI()
{
  esc="\033"
  blackf="${esc}[0;30m"
  redf="${esc}[0;31m"
  greenf="${esc}[0;32m"
  yellowf="${esc}[0;33m"
  bluef="${esc}[0;34m"
  purplef="${esc}[0;35m"
  cyanf="${esc}[0;36m"
  whitef="${esc}[0;37m"
  blackb="${esc}[0;40m"
  redb="${esc}[0;41m"
  greenb="${esc}[0;42m"
  yellowb="${esc}[0;43m"
  blueb="${esc}[0;44m"
  purpleb="${esc}[0;45m"
  cyanb="${esc}[0;46m"
  whiteb="${esc}[0;47m"
  boldon="${esc}[0;1m"
  boldoff="${esc}[0;22m"
  italicson="${esc}[0;3m"
  italicsoff="${esc}[0;23m"
  ulon="${esc}[0;4m"
  uloff="${esc}[0;24m"
  invon="${esc}[0;7m"
  invoff="${esc}[0;27m"
  reset="${esc}[0m"
}
initializeANSI

log() {
  # if the first argument is a recognized log level, output everything else with color
  if [ $# -gt 1 ]
  then
    case "$1" in
      err*)
        shift
        echo -e "${redf}$@${reset}"
        ;;
      info*|ok*)
        shift
        echo -e "${greenf}$@${reset}"
        ;;
      warn*)
        shift
        echo -e "${yellowf}$@${reset}"
        ;;
      fatal*)
        shift
        echo -e "${redf}$@${reset}"
        return 1
        ;;
      *)
        echo -e "$@"
        ;;
    esac
  else
    echo -e "$@"
  fi
}

if cmd_exists jq
then
  jless() {
    # use jq to format & colorize json, then display it inside `less`
    if [ $# -lt 1 ]
    then
      # with no arguments, jless expects stdin to be json
      jq -C . | less -rN
    elif [ $# -lt 2 ]
    then
      # single argument: a file to view
      jq -C . $1 | less -rN
    else
      # two arguments: the first is a file to read and the second is a jq pattern
      jq -C $2 $1 | less -rN
    fi
  }
fi

if test -f "$HOME/scripts/x86.py"
then
  x86() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: x86 <opcode>"
      return 1
    else
      python "$HOME/scripts/x86.py" $1 | lynx -stdin -dump
    fi
  }
fi

hex() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: hex <integer to convert>"
    return 1
  else
    python -c "print hex($1)"
  fi
}

int() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: int <hexadecimal to convert>"
    return 1
  else
    python -c "print int('$1',16)"
  fi
}

# wikipedia summary
if cmd_exists curl
then
  function wiki {
  	if [ $# -lt 1 ]
    then
      log fatal "Usage: wiki <search string>"
      return 1
    else
      curl -s -L -d "search=$1" https://en.wikipedia.org/w/index.php | w3m -T text/html -dump | less
  	fi
  }
fi

# brightness
b() {
  OPTIONS=(/sys/class/backlight/acpi_video0 /sys/class/backlight/intel_backlight /sys/class/backlight/backlight.12)
  for i in "${OPTIONS[@]}"
  do
    if test -d "$i"; then
      echo "using $i"
      SYS_DIR="$i"
    fi
  done
  if [ $# -eq 0 ]; then
    cat "$SYS_DIR/brightness"
  elif [[ "$1" -eq "max" ]]; then
    cat "$SYS_DIR/max_brightness" | sudo tee "$SYS_DIR/brightness"
  else
    echo "${1}" | sudo tee "$SYS_DIR/brightness"
  fi
}

# asus-specific keyboard brightness control
if test -f /sys/class/leds/asus::kbd_backlight/brightness
then
  kb() {
    echo "$1" | sudo tee  /sys/class/leds/asus::kbd_backlight/brightness
  }
fi

# cd and ls at once
cl() {
	if [ -d "$1" ]; then
		cd "$1"
		ls
	else
		log fatal "cl(): $1: Directory not found"
	fi
}

mkcd() {
  mkdir -p "$1"
  cd "$1"
}

# applies standard coloration for pager programs
less_color_env() {
  CMD=$1
  shift
	env \
		LESS_TERMCAP_mb=$(printf "\e[1;31m") \
		LESS_TERMCAP_md=$(printf "\e[1;31m") \
		LESS_TERMCAP_me=$(printf "\e[0m") \
		LESS_TERMCAP_se=$(printf "\e[0m") \
		LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
		LESS_TERMCAP_ue=$(printf "\e[0m") \
		LESS_TERMCAP_us=$(printf "\e[1;32m") \
			$CMD "$@"
}

alias man='less_color_env man'
alias pydoc2='less_color_env pydoc2'
alias pydoc='less_color_env pydoc'
alias less='less_color_env less'

# common valgrind usages
if cmd_exists valgrind
then
  alias memcheck='valgrind --tool=memcheck $@ --leak-check=full'
  valhalla() {
  	if [ "$#" == "0" ]; then
  		make
  		valgrind --tool=memcheck ./*.exe --leak-check=full
  	else
  		g++ -g "$1" -o "$(basename $1).out" && valgrind --tool=memcheck ./"$(basename $1).out" "${@:2}" --leak-check=full
  	fi
  }
fi

# recursive grep...
rgrep() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rgrep <pattern> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack $1 "$SEARCH_PATH"
    else
      grep -riIE $1 "$SEARCH_PATH" | grep -v \.svn | grep -v \.git
    fi
  fi
}

# ...and find...
rfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: rfind <string to find> <starting directory>"
    return 1
  else
    if [ $# -gt 1 ]
    then
      SEARCH_PATH="$2"
    else
      SEARCH_PATH="."
    fi
    if cmd_exists ack
    then
      ack -g "$1" "$SEARCH_PATH"
    else
      find "$SEARCH_PATH" -name "*$1*"
    fi
  fi
}
alias rf='rfind'

# ...with vim!
vfind() {
  if [ $# -lt 1 ]
  then
    log fatal "Usage: vfind <string to find> <starting directory>"
    return 1
  else
    vim $(rfind "$@")
  fi
}

if test -d "$HOME/notes/"
then
  note() {
    if [ $# -lt 1 ]
    then
      log fatal "Usage: note <name of note>"
      return 1
    fi
  	FILE="$HOME/notes/$1.txt"
  	if [ -f $FILE ];
  	then
  		log ok "$FILE exists"
  		vim "$FILE"
  	else
  		touch "$FILE"
  		echo "$1" | figlet > "$FILE"
  		echo "Note from $(date)" >> "$FILE"
  		vim "$FILE"
  	fi
  }
fi

ccd() {
  if [ $# -lt 2 ]
  then
    log fatal "Usage: ccd <file to copy> <directory to copy into>"
    return 1
  fi
	FILE="$1"
	if [ ! -f "$FILE" ];
	then
		log fatal "File not found"
		return 1
	fi
	DIR="$2"
	if [ ! -d "$DIR" ];
	then
		log fatal "Dir not found"
		return 1
	fi
	cp -r "$FILE" "$DIR"
	cd "$DIR"
	pwd
}

# add a directory to path, but only if it exists
# and if it's not already in path
addp() {
  if [ $# -lt 1 ]
  then
    log fatal 'Usage: addp <path to add to $PATH>'
    return 1
  fi
  if [[ -d "$1" ]]
  then
    case $1 in
      */)
        TRIMMED=$(echo "$1" | sed 's/\/$//g')
        [[ "$PATH" == *"$TRIMMED:"* ]] || export PATH="$TRIMMED:$PATH"
        ;;
      *)
        [[ "$PATH" == *"$1:"* ]] || export PATH="$1:$PATH"
        ;;
    esac
    return 0
  fi
  #log err "Path unavailable"
  return 1
}

# source a file, but only if it exists
sourcep() {
  if [[ $# -lt 1 ]]
  then
    log fatal "Usage: sourcep <path to source>"
    return 1
  fi
  if [[ -f "$1" ]]
  then
    source "$1"
    return 0
  fi
  #echo "Path unavailable"
  return 1
}

silent() {
  if [ $# -lt 1 ];
  then
    log fatal "Usage: silent <command to run>"
    return 1
  fi
  eval "$1 2>/dev/null 1>&2"
}

stdfile() {
  if [ $# -lt 1 ];
  then
    log fatal "Usage: stdfile <command to redirect stout and stderr to separate files over>"
    return 1
  fi
  eval "$1 2>./stderr 1>./stdout"
}

# use it like scp!
lss() {
  H=$(echo $1 | awk -F':' '{print $1}')
  F=$(echo $1 | awk -F':' '{print $2}')
  /usr/bin/ssh $H "ls $F"
}

histogram() {
  if [[ $# -lt 1 ]]
  then     
    # changed 2016-02-21: this is useful default behavior
    sort | uniq -c | sort -n
  elif [[ $# -lt 2 ]]
  then
    COL="\$$1"
    awk "{print $COL}" | sort | uniq -c | sort -n
  else
    COL="\$$1"
    awk -F"$2" "{print $COL}" | sort | uniq -c | sort -n
  fi
  return 0
}

lsfunc() {
  typeset -F | awk '{print $NF}'
}

isgit() {
  [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1
}

issvn() {
  svn info >/dev/null 2>&1
}

# wraps version control software
vc() {
  command=${1:-"status"}
  case "${command}" in
    status)
      isgit && git status
      issvn && svn status
      ;;
    up)
      isgit && git pull
      issvn && svn update
      ;;
    push)
      isgit && git push
      issvn && svn commit
      ;;
    *)
      log fatal "Usage: vc <status|up|push>"
      return 1
  esac
}

license() {
  # get me a damn license!
  COMMAND="$1"
  declare -A LICENSES
  LICENSES=(
    ["gplv3"]="https://www.gnu.org/licenses/gpl-3.0.txt"
    ["agplv3"]="https://www.gnu.org/licenses/agpl-3.0.txt"
    ["lgplv3"]="https://www.gnu.org/licenses/lgpl-3.0.txt"
    ["apache"]="https://www.apache.org/licenses/LICENSE-2.0.txt"
    ["wtfpl"]="http://www.wtfpl.net/txt/copying/"
    ["mit"]="https://mit-license.org/license.txt"
    ["mozilla"]="https://www.mozilla.org/media/MPL/2.0/index.txt"
  )
  case $COMMAND in
    list)
      for k in "${!LICENSES[@]}"
      do
        echo "$k"
      done
      ;;
    get)
      if [ $# -lt 2 ]
      then
        log err "license get requires an argument, the name of license to download"
        return 1
      fi
      REQUEST="$2"
      if [[ "${LICENSES[$REQUEST]}" ]]
      then
        if hash curl
        then
          HTTP_METHOD="$(which curl) -s"
        elif hash wget
        then
          HTTP_METHOD="$(which wget) -O -"
        else
          log err "Cannot find executables for curl or wget, install one"
          return 1
        fi
        $HTTP_METHOD "${LICENSES[$REQUEST]}"
      else
        log err 'The argument you gave is not a recognized license name, try `license list`'
      fi
      ;;
    help|*)
      echo "Commands:"
      echo "  list: list known licenses"
      echo "  get: download a license locally"
      echo "  help: view this help output"
      ;;
  esac
}

sudo_with_confirmation() {
  echo "This program would like to use your elevated privileges to run the following command:"
  echo
  echo "$@"
  echo
  echo 'Is this ok?'
  select confirmation in "Yes" "No"; do
    case "$confirmation" in
      Yes ) 
        sudo $@
        return $?
        ;;
      No )
        echo 'Not executing, bailing out'
        return 1
        ;;
    esac
  done
}

witch() {
  which "$1" 2>/dev/null
  if [ $? -ne 0 ]; then
    typeset -f "$1"
    if [ $? -ne 0 ]; then
      alias "$1"
    fi
  fi
}

# expand my environment pls
if test -d "$HOME/dev/go/"
then
  export GOBIN="$HOME/dev/go/bin"
  addp "$HOME/dev/go/bin"
  export GOPATH="$HOME/dev/go"
fi
sourcep "$HOME/.localaliasrc"
addp "$HOME/scripts"
addp "$HOME/bin"
addp "$HOME/.local/bin"
